---
title: "Chaînes de caractères"
icon: "mdi:comment-quote-outline"
layout: "/src/layouts/Page.astro"
---

## `char`

Nous avons déjà vu le type `char` comme un type numérique stocké sur 1 octet.
Or `char` signifie « character » qui veut dire « caractère » car un `char` est
généralement utilisé pour stocker un caractère :

```c
char c = 'A';
printf("%c\n", c);
```

Un caractère s'écrit toujours entre guillemets simples. La correspondance
entre les caractères et les nombres se fait avec la tablea ASCII dont nous
avons déja parlé :

Table ASCII Dec | Hex | Bin | Caractère | Dec | Hex | Bin | Caract | Dec | Hex | Bin | Caract  
---|---|---|---|---|---|---|---|---|---|---|---  
0| 0| 0| [Null] | 43| 2B| 101011| + | 86| 56| 1010110| V  
1| 1| 1| [Start of Heading] | 44| 2C| 101100| , | 87| 57| 1010111| W  
2| 2| 10| [Start of Text] | 45| 2D| 101101| - | 88| 58| 1011000| X  
3| 3| 11| [End of Text] | 46| 2E| 101110| . | 89| 59| 1011001| Y  
4| 4| 100| [End of Transmission] | 47| 2F| 101111| / | 90| 5A| 1011010| Z  
5| 5| 101| [Enduiry] | 48| 30| 110000| 0 | 91| 5B| 1011011| [  
6| 6| 110| [Acknowledge] | 49| 31| 110001| 1 | 92| 5C| 1011100| \  
7| 7| 111| [Bell] | 50| 32| 110010| 2 | 93| 5D| 1011101| ]  
8| 8| 1000| [Backspace] | 51| 33| 110011| 3 | 94| 5E| 1011110| ^  
9| 9| 1001| [Horizontal Tab] | 52| 34| 110100| 4 | 95| 5F| 1011111| _  
10| A| 1010| [Linefeed] | 53| 35| 110101| 5 | 96| 60| 1100000| `  
11| B| 1011| [Vertical Tab] | 54| 36| 110110| 6 | 97| 61| 1100001| a  
12| C| 1100| [Form Feed] | 55| 37| 110111| 7 | 98| 62| 1100010| b  
13| D| 1101| [Carriage Return] | 56| 38| 111000| 8 | 99| 63| 1100011| c  
14| E| 1110| [Shift Out] | 57| 39| 111001| 9 | 100| 64| 1100100| d  
15| F| 1111| [Shift In] | 58| 3A| 111010| : | 101| 65| 1100101| e  
16| 10| 10000| [Data Link Escape] | 59| 3B| 111011| ; | 102| 66| 1100110| f  
17| 11| 10001| [Device Control 1] | 60| 3C| 111100|  | 103| 67| 1100111| g  
18| 12| 10010| [Device Control 2] | 61| 3D| 111101| = | 104| 68| 1101000| h  
19| 13| 10011| [Device Control 3] | 62| 3E| 111110| > | 105| 69| 1101001| i  
20| 14| 10100| [Device Control 4] | 63| 3F| 111111| ? | 106| 6A| 1101010| j  
21| 15| 10101| [Negative Acknowledge] | 64| 40| 1000000| @ | 107| 6B| 1101011| k  
22| 16| 10110| [Synchronous Idle] | 65| 41| 1000001| A | 108| 6C| 1101100| l  
23| 17| 10111| [Eng of Trans. Block] | 66| 42| 1000010| B | 109| 6D| 1101101| m  
24| 18| 11000| [Cancel] | 67| 43| 1000011| C | 110| 6E| 1101110| n  
25| 19| 11001| [End of Medium] | 68| 44| 1000100| D | 111| 6F| 1101111| o  
26| 1A| 11010| [Substitute] | 69| 45| 1000101| E | 112| 70| 1110000| p  
27| 1B| 11011| [Escape] | 70| 46| 1000110| F | 113| 71| 1110001| q  
28| 1C| 11100| [File Separator] | 71| 47| 1000111| G | 114| 72| 1110010| r  
29| 1D| 11101| [Group Separator] | 72| 48| 1001000| H | 115| 73| 1110011| s  
30| 1E| 11110| [Record Separator] | 73| 49| 1001001| I | 116| 74| 1110100| t  
31| 1F| 11111| [Unit Separator] | 74| 4A| 1001010| J | 117| 75| 1110101| u  
32| 20| 100000|  | 75| 4B| 1001011| K | 118| 76| 1110110| v  
33| 21| 100001| ! | 76| 4C| 1001100| L | 119| 77| 1110111| w  
34| 22| 100010| " | 77| 4D| 1001101| M | 120| 78| 1111000| x  
35| 23| 100011| # | 78| 4E| 1001110| N | 121| 79| 1111001| y  
36| 24| 100100| $ | 79| 4F| 1001111| O | 122| 7A| 1111010| z  
37| 25| 100101| % | 80| 50| 1010000| P | 123| 7B| 1111011| `{`  
38| 26| 100110| & | 81| 51| 1010001| Q | 124| 7C| 1111100| |  
39| 27| 100111| ' | 82| 52| 1010010| R | 125| 7D| 1111101| `}`  
40| 28| 101000| `(` | 83| 53| 1010011| S | 126| 7E| 1111110| ~  
41| 29| 101001| `)` | 84| 54| 1010100| T | 127| 7F| 1111111| [DEL]  
42| 2A| 101010| * | 85| 55| 1010101| U | | | |   
  
Seul les nombres de 0 à 127 correspondent à des caractères, les 128 autres
nombres de 128 à 255 n'ont pas d'équivalence.

Il est possible d'initialiser un `char` avec un nombre ou un caractère. On
peut également l'afficher comme un caractère avec le marqueur `%c` ou comme un
nombre avec le marqueur `%d` :

```c
char c1 = 64;
printf("%d\n", c1);
printf("%c\n", c1);
char c2 = '@';
printf("%d\n", c2);
printf("%c\n", c2);
```

**1)** Écrire un programme qui affiche la liste des codes ASCII et de leur
caractère correspondant pour les valeurs allant de 32 à 126. La sortie du
programme devra commencer par ces lignes :

```c
32 :  
33 : !
34 : "
35 : #
…


for (char i = 32; i <= 126; i++) {
    printf("%d : %c\n", i, i);
}
```

## Chaîne de caratères

### Définition

En C, une chaîne de caractères est un tableau de caractères, donc un tableau
de `char`. On peut définir une chaîne de caractères comme un tableau :

```c
char chaine[] = {'H', 'e', 'l', 'l', 'o', '!'};
```

Il est néanmoins possible de définir une chaîne de caractère de manière plus
conviviale en encadrant simplement la chaîne de guillemets doubles :

```c
char chaine[] = "Hello!";
```

### Propriétés

Une chaîne de caratères est un tableau particulier car le compilateur ajoute
systématiquement le caractère `'\0'` (code ASCII 0) à la fin de la chaîne. Il
n'est donc pas nécéssaire de conserver ailleurs la longueur de la chaîne, il
est possible de la retrouver. Par exemple, la chaîne précédente est stockée
sous la forme : `{'H', 'e', 'l', 'l', 'o', '!', '\0'}`

**2)** Pour vérifier cela, proposer un programme qui affiche tous les
caractères de la chaîne `Hello!` mais qui affiche également le suivant. On
affichera le code ASCII de chaque caractère. (On rappelle qu'on accède aux
éléments d'un tableau avec la notation `chaine[i]`).

```c
char chaine[] = "Hello!";
for (int i=0; i<=17; i++) {
    printf("%c : %d\n", chaine[i], chaine[i]);
}
```

### Affichage

Il est possible d'afficher une chaîne de caractères dans un `printf` avec le
marqueur `%s` :

```c
char chaine[] = "Hello!";
printf("%s\n", chaine);
```

### `string.h`

La bibliothèque `string.h` fournit un grand nombre de fonctions sur les
chaînes de caractères. La plus utile étant la fonction `strlen` qui renvoie la
taille d'une chaînes de caractères.

```c
char chaine[] = "Hello!";
printf("%ld\n", strlen(chaine));
```

On pourra avoir besoin de la fonction `strcpy` qui permet de copier une chaîne
dans une autre :

```c
char chaine[10];
strcpy(chaine, "Hello!");
/* 	On ne peut plus faire chaine = "Hello!"
    car le compilateur ne le permet qu'a la déclaration */
```

La fonction `strcmp` permet de comparer deux chaînes de caractère car il n'est
pas possible de les comparer avec `==`. Elle renvoie `0` si les chaînes sont
identiques et une valeur différente de `0` sinon.

**3)** Créer une fonction `myStrlen` qui prend en paramètre une chaîne de
caractères et renvoie le nombre de caractères qu'elle contient. Il ne faut pas
utiliser `string.h` !

```c
int myStrlen(char chaine[]) {
    int i = 0;
    while (chaine[i] != 0) {
        i++;
    }
    return i;
}
```

**4)** Compléter le programme ci-dessous qui demande à l'utilisateur un mot de
passe et vérifie s'il est juste :

```c
const char password[] = "azerty";

…

if ( … ) {
    printf("Le mot de passe est bon\n");
} else {
    printf("Le mot de passe est faux\n");
}


const char password[] = "azerty";

char input[10];

printf("Saisissez le mot de passe\n");
scanf("%s", input);


if (strcmp(password, input) == 0) {
    printf("Le mot de passe est bon\n");
} else {
    printf("Le mot de passe est faux\n");
}
```
