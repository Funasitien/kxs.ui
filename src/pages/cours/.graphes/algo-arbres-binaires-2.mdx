---
title: "Algorithmes sur les arbres binaires"
icon: "mdi:paper-remove"
layout: "@root/layouts/Page.astro"
---

  * [cours](https://kxs.fr/cours/)
  * [sujets](https://kxs.fr/sujets/)
  * [fiches](https://kxs.fr/fiches/)

[![Logo de kxs.fr](/img/logo.svg)](https://kxs.fr/)[Cours d'informatique pour
le lycée et la prépa](https://kxs.fr/cours/)

## Graphes et algorithmes

  * [Introduction](.)
  * [Graphes](graphes)
  * [Arbres](arbres)
  * [Arbres binaires](arbres-binaires)
  * [Algo arbres binaires (1)](algo-arbres-binaires-1)
  * [Implémentation arbres](implementation-arbres)
  * [Algo arbres binaires (2)](algo-arbres-binaires-2)
  * [Algo graphes](algo-graphes)
  * [Implémentation graphes](implementation-graphes)

# Algorithmes sur les arbres binaires (Partie 2)

Ici, nous allons découvrir un type d'arbre particulier : les _arbres binaires
de recherche_ (ABR). Ce sont des structures de données commposées de clés
ordonnées pour lesquelles la recherhe, suppression et insertion sont
relativement rapides. Ils peuvent être utilisés dans des ensembles ou des
tableau associatifs pour effectuer des opérations rapides sur leurs éléments.

## Définition

Un arbre binaire de recherche est un arbre binaire dans lequel chaque nœud
possède une clé, telle que chaque nœud du sous-arbre gauche ait une clé
inférieure ou égale à celle du nœud considéré, et que chaque nœud du sous-
arbre droit possède une clé supérieure ou égale à celle-ci

Voici un exemple de ABR :

![](img/arbre-recherche.svg)

ainsi que sa représentation en tableau (liste) :

    
    
    arbre = [8, [3, [1, None, None], [6, [4, None, None], [7, None, None]]], [10, None, [14, [13, None, None], None]]]

Nous utilisons un tableau plutôt qu'un tuple car nous allons modifier l'arbre.

**1)** Est-ce bien un abre binaire de recherche ?

**2)** Appliquez le parcours infixe à cet abre, que remarquez-vous ?

## Recherche d'un élément

L'un des intérêts des ABR est de pouvoir chercher rapidement un élément. Voici
un algorithme faisant ce travail :

    
    
    recherche(nœud, clé):
        si nœud est vide:
            retourner FAUX
        sinon:
            si nœud.clé = clé:
                retourner VRAI
            si nœud.clé > clé:
                retourner recherche(nœud.gauche, clé)
            si nœud.clé < clé:
                retourner recherche(nœud.droit, clé)

Cet algorithme est proche d'un algorithme de recherche par dichotomie utilisé
dans un tableau. Ça complexité est donc la même : O(log(n)).

**3)** Proposez une implémentation en Python de cet algorithme et testez son
résultat sur la recherche de des clés « 7 » et « 9 ».

## Insertion

Voici une implémentation en Python d'un algorithme d'insertion d'un nouvel
élément dans un ABR :

    
    
    def insertionABR(arbre,element):
        if arbre[0] > element:
            if arbre[1] is not None:
                insertionABR(arbre[1],element)
            else:
                arbre[1] = [element, None, None]
                print(element, 'ajouté à gauche de', arbre[0])
        if arbre[0] < element:
            if arbre[2] is not None:
                insertionABR(arbre[2],element)
            else:
                arbre[2] = [element, None, None]
                print(element, 'ajouté à droite de', arbre[0])

**4)** Cet algorithme est-il récursif ?

**5)** Que va-t-il afficher si on exécute la commande `insertionABR(arbre,12)`
?

**6)** Que va-t-il afficher si on exécute la commande `insertionABR(arbre,9)`
?

**7)** Proposez un algorithme non récursif (en Python ou en langage naturel)
pour insérer un élément.

[Précédent](implementation-arbres)[Suivant](algo-graphes)

[Cours de NSI et MP2I](https://kxs.fr/cours/) par Thomas Beline sous la
licence [CC BY-SA 4.0
![ccbysa](/img/ccbysa.svg)](https://creativecommons.org/licenses/by-
sa/4.0/deed.fr)

