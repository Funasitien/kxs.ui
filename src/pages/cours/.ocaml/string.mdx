---
title: "String en OCaml - Niveau MP2I"
icon: "mdi:paper-remove"
layout: "@root/layouts/Page.astro"
---

  * [cours](https://kxs.fr/cours/)
  * [sujets](https://kxs.fr/sujets/)
  * [fiches](https://kxs.fr/fiches/)

[![Logo de kxs.fr](/img/logo.svg)](https://kxs.fr/)[Cours d'informatique pour
le lycée et la prépa](https://kxs.fr/cours/)

## OCaml

  * [Présentation](.)
  * [Interaction et définitions](interaction-definition)
  * [Fonctions](fonctions)
  * [If … then … else …](if-then-else)
  * [Fonctions récursives](fonctions-recursives)
  * [Réels](reels)
  * [Chaînes de caractères](string)
  * [Execices 1](exercices-1)
  * [Listes](listes)
  * [Unit](unit)
  * [Produits](produits)
  * [Enregistrements](enregistrements)
  * [Énumérations](enumerations)
  * [Sommes](sommes)
  * [Filtrage](filtrage)
  * [Fonctions avancées](fonctions-avancees)
  * [Aspects impértifs](aspects-imperatifs)

# Chaînes de caractères

## Définitions

Il existe en OCaml des caractères (entre apostrophes) de type `char` et des
chaînes de caractères (entre guillemets) de type `string` :

    
    
    # 'a';;
    - : char = 'a'
    # "abcd";;
    - : string = "abcd"

Il existe plusieurs façons de saisir un caractère :

  * en le tapant directement au clavier
  * en écrivant son code ASCII décimal sur trois chiffres précédé d'un `\` : `\097` pour `a`
  * en utilisant un caractère d'échappement `\` quand c'est nécessaire :

Caractères d'échappement Caractère | Signification  
---|---  
\n| saut à la ligne  
\t| tabulation  
\\\| antislash  
\"| guillemet double  
\'| guillemet simple (inutile pour les strings)  
  
## Opérations

Il est possible de concaténer des chaînes de caractères avec l'opérateur `^` :

    
    
    # "debut" ^ "fin";;
    - : string = "debutfin"

## Accès aux éléments

Pour accéder aux éléments d'une chaîne de caractères, on utilise la notation
`chaine.[i]` où `i` est la position de l'élement dans la chaîne :

    
    
    # let chaine = "abcde";;
    val chaine : string = "abcde"
    # chaine.[2];;
    - : char = 'c'

On récupère alors un élément de type `char`.

## Conversions

  * `float_of_string` : string vers float
  * `int_of_string` : string vers int
  * `string_of_int` : int vers string
  * `string_of_float` : float vers string

## Fonctions

  * `Char.code c` : donne le code ASCII du caractère c
  * `Char.chr n` : donne le caractère correpondant au code ASCII n
  * `String.make n c` : renvoie une chaîne avec n fois le caractère c (permet de convertir un caractère en chaine)
  * `String.length s` : renvoie longueur de la chaine s
  * `String.get s n` : renvoie le nième caractère de la chaine s (équivalent à s.[n])
  * `String.sub s d l` : renvoie la sous chaîne de s commencant à la position d et de longueur l

## Exercices

**1)** Écrire un fonction `dernier` qui renvoie le dernier élément d'une
chaîne de caractères.

    
    
    # let dernier s = s.[String.length s - 1];;
    val dernier : string -> char = <fun>

**2)** Déterminer les résultats des expressions suivantes sans utiliser
l'interpréteur OCaml (il peut y avoir des erreurs) :

  1. `"Le resultat est : " ^ string_of_int(2*7);;`
  2. `float_of_string("4.3") +. 2.2;;`
  3. `String.get "Bonjour" 0;;`
  4. `String.get "Bonjour" 3;;`
  5. `String.get "Bonjour" 8;;`
  6. `String.sub "Bonjour" 0 3;;`
  7. `String.sub "Bonjour" 3 (String.length "Bonjour" - 3);;`
  8. `String.make 3 'a';;`

    
    
    # "Le resultat est" ^ string_of_int(2*7);;
    - : string = "Le resultat est14"
    # float_of_string("4.3") +. 2.2;;
    - : float = 6.5     
    # String.get "Bonjour" 0;;
    - : char = 'B'    
     # String.get "Bonjour" 3;;
    - : char = 'j' 
    # String.get "Bonjour" 8;;
    Exception: Invalid_argument "index out of bounds".  
    # String.sub "Bonjour" 0 3;;
    - : string = "Bon"     
    # String.sub "Bonjour" 3 (String.length "Bonjour" - 3);;
    - : string = "jour"
    # String.make 3 'a';;
    - : string = "aaa"

**3)** Écrire une fonction récursive qui affiche les code ASCII de 32 à 127 et
les caractères correspondants. On aura besoin des fonctions `print_char`,
`print_int` et `print_newline ()`. On peut séparer des instructions par `;` et
les regrouper entre parenthèses.

    
    
    # let rec ascii n =
    if n<128 then (print_int n;print_char ':';print_char (Char.chr n);print_newline ();ascii (n+1))
    else ()
    val ascii : int -> unit = <fun>

[Précédent](reels)[Suivant](exercices-1)

[Cours de NSI et MP2I](https://kxs.fr/cours/) par Thomas Beline sous la
licence [CC BY-SA 4.0
![ccbysa](/img/ccbysa.svg)](https://creativecommons.org/licenses/by-
sa/4.0/deed.fr)

